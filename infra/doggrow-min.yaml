AWSTemplateFormatVersion: '2010-09-09'
Description: DogGrow minimal backend (Lambda Function URLs + DynamoDB + S3)

Parameters:
  PhotosPrefix:
    Type: String
    Default: public/
  CORSOrigin:
    Type: String
    Default: "*"

Resources:
  PhotosBucket:
    Type: AWS::S3::Bucket
    Properties:
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        BlockPublicPolicy: false
        IgnorePublicAcls: true
        RestrictPublicBuckets: false

  PhotosBucketPolicy:
    Type: AWS::S3::BucketPolicy
    Properties:
      Bucket: !Ref PhotosBucket
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Sid: AllowPublicReadUnderPrefix
            Effect: Allow
            Principal: "*"
            Action: s3:GetObject
            Resource: !Sub arn:aws:s3:::${PhotosBucket}/${PhotosPrefix}*

  PetsTable:
    Type: AWS::DynamoDB::Table
    Properties:
      BillingMode: PAY_PER_REQUEST
      AttributeDefinitions: [{ AttributeName: userId, AttributeType: S }]
      KeySchema: [{ AttributeName: userId, KeyType: HASH }]

  TasksTable:
    Type: AWS::DynamoDB::Table
    Properties:
      BillingMode: PAY_PER_REQUEST
      AttributeDefinitions:
        - { AttributeName: userId, AttributeType: S }
        - { AttributeName: taskId, AttributeType: S }
      KeySchema:
        - { AttributeName: userId, KeyType: HASH }
        - { AttributeName: taskId, KeyType: RANGE }

  SubsTable:
    Type: AWS::DynamoDB::Table
    Properties:
      BillingMode: PAY_PER_REQUEST
      AttributeDefinitions:
        - { AttributeName: userId, AttributeType: S }
        - { AttributeName: submissionId, AttributeType: S }
      KeySchema:
        - { AttributeName: userId, KeyType: HASH }
        - { AttributeName: submissionId, KeyType: RANGE }

  CommonLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal: { Service: lambda.amazonaws.com }
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: AppRW
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action: [ dynamodb:GetItem, dynamodb:PutItem, dynamodb:UpdateItem, dynamodb:DeleteItem, dynamodb:Query ]
                Resource:
                  - !GetAtt PetsTable.Arn
                  - !GetAtt TasksTable.Arn
                  - !GetAtt SubsTable.Arn
              - Effect: Allow
                Action: [ s3:PutObject, s3:GetObject ]
                Resource: !Sub arn:aws:s3:::${PhotosBucket}/*

  TasksFn:
    Type: AWS::Lambda::Function
    Properties:
      Role: !GetAtt CommonLambdaRole.Arn
      Runtime: nodejs20.x
      Handler: index.handler
      Timeout: 10
      Environment:
        Variables:
          TASKS_TABLE: !Ref TasksTable
          PETS_TABLE: !Ref PetsTable
          SUBS_TABLE: !Ref SubsTable
          BUCKET: !Ref PhotosBucket
          PREFIX: !Ref PhotosPrefix
      Code:
        ZipFile: |
          import { DynamoDBClient, PutItemCommand, QueryCommand, UpdateItemCommand, DeleteItemCommand } from "@aws-sdk/client-dynamodb";
          import { marshall, unmarshall } from "@aws-sdk/util-dynamodb";
          const ddb = new DynamoDBClient({});
          const json = (status, body, origin="*") => ({
            statusCode: status,
            headers: { "Content-Type":"application/json", "Access-Control-Allow-Origin": origin, "Access-Control-Allow-Headers": "*" },
            body: JSON.stringify(body)
          });
          export const handler = async (event) => {
            const origin = "*";
            if (event.requestContext.http?.method === "OPTIONS") return json(200, {}, origin);
            const userId = event.headers?.["x-user-id"] || event.headers?.["X-User-Id"];
            if (!userId) return json(400, { error:"missing x-user-id" }, origin);
            const action = event.queryStringParameters?.action || (event.httpMethod==="GET"?"list":null);
            try {
              if (event.httpMethod === "GET" && action === "list") {
                const q = await ddb.send(new QueryCommand({
                  TableName: process.env.TASKS_TABLE,
                  KeyConditionExpression: "userId = :u",
                  ExpressionAttributeValues: { ":u": { S: userId } }
                }));
                const items = q.Items?.map(unmarshall).filter(t => !t.completedAt) || [];
                return json(200, items, origin);
              }
              if (event.httpMethod === "POST" && action === "create") {
                const body = JSON.parse(event.body||"{}");
                const taskId = crypto.randomUUID();
                const item = { userId, taskId, title: body.title||"Task", active: true, createdAt: new Date().toISOString() };
                await ddb.send(new PutItemCommand({ TableName: process.env.TASKS_TABLE, Item: marshall(item) }));
                return json(200, item, origin);
              }
              if (event.httpMethod === "PUT" && action === "update") {
                const body = JSON.parse(event.body||"{}");
                const { taskId, title, active } = body;
                const expr = []; const vals = {};
                if (title!==undefined){ expr.push("title=:t"); vals[":t"] = { S: title }; }
                if (active!==undefined){ expr.push("active=:a"); vals[":a"] = { BOOL: !!active }; }
                await ddb.send(new UpdateItemCommand({
                  TableName: process.env.TASKS_TABLE,
                  Key: { userId: {S:userId}, taskId:{S:taskId} },
                  UpdateExpression: "SET "+expr.join(", "),
                  ExpressionAttributeValues: vals
                }));
                return json(200, { ok:true }, origin);
              }
              if (event.httpMethod === "DELETE" && action === "delete") {
                const { taskId } = JSON.parse(event.body||"{}");
                await ddb.send(new DeleteItemCommand({
                  TableName: process.env.TASKS_TABLE,
                  Key: { userId:{S:userId}, taskId:{S:taskId} }
                }));
                return json(200, { ok:true }, origin);
              }
              if (event.httpMethod === "POST" && action === "complete") {
                const { taskId, photoKey } = JSON.parse(event.body||"{}");
                const now = new Date().toISOString();
                await ddb.send(new UpdateItemCommand({
                  TableName: process.env.TASKS_TABLE,
                  Key: { userId:{S:userId}, taskId:{S:taskId} },
                  UpdateExpression: "SET completedAt=:c",
                  ExpressionAttributeValues: { ":c": { S: now } }
                }));
                const submissionId = crypto.randomUUID();
                const sub = { userId, submissionId, taskId, photoKey, createdAt: now };
                await ddb.send(new PutItemCommand({ TableName: process.env.SUBS_TABLE, Item: marshall(sub) }));
                await ddb.send(new UpdateItemCommand({
                  TableName: process.env.PETS_TABLE,
                  Key: { userId:{S:userId} },
                  UpdateExpression: "ADD foodJar :one, xp :ten SET #lvl = if_not_exists(#lvl, :oneVal), health = if_not_exists(health, :h), lastGrowthAt = :now",
                  ExpressionAttributeNames: { "#lvl":"level" },
                  ExpressionAttributeValues: { ":one": {N:"1"}, ":ten":{N:"10"}, ":oneVal":{N:"1"}, ":h":{N:"80"}, ":now":{S:now} }
                }));
                return json(200, { ok:true, submissionId, photoKey }, origin);
              }
              return json(400, { error:"unsupported" }, origin);
            } catch (e) {
              console.error(e);
              return json(500, { error:String(e) }, origin);
            }
          };

  TasksFnUrl:
    Type: AWS::Lambda::Url
    Properties:
      TargetFunctionArn: !GetAtt TasksFn.Arn
      AuthType: NONE
      Cors:
        AllowOrigins: [ !Ref CORSOrigin ]
        AllowMethods: [ "GET", "POST", "PUT", "DELETE", "OPTIONS" ]
        AllowHeaders: [ "*" ]

  PetFn:
    Type: AWS::Lambda::Function
    Properties:
      Role: !GetAtt CommonLambdaRole.Arn
      Runtime: nodejs20.x
      Handler: index.handler
      Timeout: 10
      Environment:
        Variables: { PETS_TABLE: !Ref PetsTable }
      Code:
        ZipFile: |
          import { DynamoDBClient, GetItemCommand, PutItemCommand, UpdateItemCommand } from "@aws-sdk/client-dynamodb";
          import { marshall, unmarshall } from "@aws-sdk/util-dynamodb";
          const ddb = new DynamoDBClient({});
          const json = (s,b,o="*")=>({statusCode:s,headers:{"Content-Type":"application/json","Access-Control-Allow-Origin":o,"Access-Control-Allow-Headers":"*"},body:JSON.stringify(b)});
          export const handler = async (event)=>{
            const origin="*";
            if (event.requestContext.http?.method==="OPTIONS") return json(200,{},origin);
            const userId = event.headers?.["x-user-id"] || event.headers?.["X-User-Id"];
            if(!userId) return json(400,{error:"missing x-user-id"},origin);
            const action = event.queryStringParameters?.action || "get";
            try{
              if(action==="get"){
                const r = await ddb.send(new GetItemCommand({ TableName: process.env.PETS_TABLE, Key:{ userId:{S:userId} } }));
                if(!r.Item){
                  const pet = { userId, level:1, xp:0, health:80, foodJar:0 };
                  await ddb.send(new PutItemCommand({ TableName: process.env.PETS_TABLE, Item: marshall(pet) }));
                  return json(200, pet, origin);
                }
                return json(200, unmarshall(r.Item), origin);
              }
              if(action==="feed"){
                const now = new Date().toISOString();
                await ddb.send(new UpdateItemCommand({
                  TableName: process.env.PETS_TABLE,
                  Key:{ userId:{S:userId} },
                  UpdateExpression: "SET health = if_not_exists(health, :h), foodJar = if_not_exists(foodJar, :z) ADD health :inc SET foodJar = foodJar - :one, lastFedAt = :now",
                  ConditionExpression: "foodJar >= :one",
                  ExpressionAttributeValues:{ ":inc":{N:"10"}, ":one":{N:"1"}, ":h":{N:"80"}, ":z":{N:"0"}, ":now":{S:now} }
                }));
                return json(200, { ok:true }, origin);
              }
              return json(400,{error:"unsupported"},origin);
            }catch(e){ return json(500,{error:String(e)},origin); }
          };

  PetFnUrl:
    Type: AWS::Lambda::Url
    Properties:
      TargetFunctionArn: !GetAtt PetFn.Arn
      AuthType: NONE
      Cors:
        AllowOrigins: [ !Ref CORSOrigin ]
        AllowMethods: [ "GET", "POST", "OPTIONS" ]
        AllowHeaders: [ "*" ]

  PresignFn:
    Type: AWS::Lambda::Function
    Properties:
      Role: !GetAtt CommonLambdaRole.Arn
      Runtime: nodejs20.x
      Handler: index.handler
      Timeout: 10
      Environment:
        Variables:
          BUCKET: !Ref PhotosBucket
          PREFIX: !Ref PhotosPrefix
      Code:
        ZipFile: |
          import { S3RequestPresigner } from "@aws-sdk/s3-request-presigner";
          import { parseUrl } from "@smithy/url-parser";
          import { HttpRequest } from "@smithy/protocol-http";
          import { S3Client } from "@aws-sdk/client-s3";
          const s3 = new S3Client({});
          const signer = new S3RequestPresigner({ ...s3.config });
          const json = (s,b,o="*")=>({statusCode:s,headers:{"Content-Type":"application/json","Access-Control-Allow-Origin":o,"Access-Control-Allow-Headers":"*"},body:JSON.stringify(b)});
          export const handler = async (event)=>{
            const origin="*";
            if (event.requestContext.http?.method==="OPTIONS") return json(200,{},origin);
            const userId = event.headers?.["x-user-id"] || event.headers?.["X-User-Id"];
            if(!userId) return json(400,{error:"missing x-user-id"},origin);
            const { contentType="image/jpeg" } = JSON.parse(event.body||"{}");
            const key = `${process.env.PREFIX}${userId}/${Date.now()}.jpg`;
            const url = `https://${process.env.BUCKET}.s3.amazonaws.com/${key}`;
            const req = new HttpRequest({ ...parseUrl(url), method:"PUT", headers:{ "content-type": contentType }});
            const signed = await signer.presign(req, { expiresIn: 3600 });
            return json(200, { uploadUrl: signed.href, photoKey: key }, origin);
          };

  PresignFnUrl:
    Type: AWS::Lambda::Url
    Properties:
      TargetFunctionArn: !GetAtt PresignFn.Arn
      AuthType: NONE
      Cors:
        AllowOrigins: [ !Ref CORSOrigin ]
        AllowMethods: [ "POST", "OPTIONS" ]
        AllowHeaders: [ "*" ]

Outputs:
  TasksUrl:
    Value: !GetAtt TasksFnUrl.FunctionUrl
  PetUrl:
    Value: !GetAtt PetFnUrl.FunctionUrl
  PresignUrl:
    Value: !GetAtt PresignFnUrl.FunctionUrl
  BucketName:
    Value: !Ref PhotosBucket

